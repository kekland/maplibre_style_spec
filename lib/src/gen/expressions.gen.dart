// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by tool/style/generate_style_code.js

import 'package:maplibre_style_spec/src/_src.dart';
import 'package:maplibre_style_spec/src/expression/definitions/_definitions.dart';

/// Gets the current zoom level.  Note that in style layout and paint properties, ["zoom"] may only appear as the input to a top-level "step" or "interpolate" expression.
class ZoomExpression extends Expression<num> {
  const ZoomExpression() : super();

  /// Creates a new instance of [ZoomExpression] by parsing the given [args] as a JSON list.
  factory ZoomExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'zoom', 'Invalid expression type: ${args[0]}, expected [zoom]');

    return const ZoomExpression();
  }

  @override
  num evaluate(EvaluationContext context) {
    return zoomExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Retrieves an item from an array.
class AtExpression extends Expression<dynamic> {
  const AtExpression({
    required this.index,
    required this.array,
    super.type,
  }) : super();

  /// Creates a new instance of [AtExpression] by parsing the given [args] as a JSON list.
  factory AtExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'at', 'Invalid expression type: ${args[0]}, expected [at]');

    var i = 1;

    // Parse arg0
    Expression<int> arg0;

    arg0 = Expression<int>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<List<dynamic>> arg1;

    arg1 = Expression<List<dynamic>>.fromJson(args[i]);
    i++;

    return AtExpression(
      index: arg0,
      array: arg1,
    );
  }

  final Expression<int> index;
  final Expression<List<dynamic>> array;

  @override
  dynamic evaluate(EvaluationContext context) {
    return atExpressionImpl(
      context,
      index,
      array,
    );
  }

  @override
  List<Object?> get props => [
        index,
        array,
      ];

  @override
  bool get stringify => true;
}

/// Determines whether an item exists in an array or a substring exists in a string.
///
///  - [Measure distances](https://maplibre.org/maplibre-gl-js/docs/examples/measure/)
class InExpression extends Expression<dynamic> {
  const InExpression({
    required this.needle,
    required this.haystack,
    super.type,
  }) : super();

  /// Creates a new instance of [InExpression] by parsing the given [args] as a JSON list.
  factory InExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'in', 'Invalid expression type: ${args[0]}, expected [in]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return InExpression(
      needle: arg0,
      haystack: arg1,
    );
  }

  final Expression<dynamic> needle;
  final Expression<dynamic> haystack;

  @override
  dynamic evaluate(EvaluationContext context) {
    return inExpressionImpl(
      context,
      needle,
      haystack,
    );
  }

  @override
  List<Object?> get props => [
        needle,
        haystack,
      ];

  @override
  bool get stringify => true;
}

/// Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search. In a string, a UTF-16 surrogate pair counts as a single position.
class IndexOfExpression extends Expression<int> {
  const IndexOfExpression({
    required this.needle,
    required this.haystack,
    super.type,
  }) : super();

  /// Creates a new instance of [IndexOfExpression] by parsing the given [args] as a JSON list.
  factory IndexOfExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'index-of', 'Invalid expression type: ${args[0]}, expected [index-of]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return IndexOfExpression(
      needle: arg0,
      haystack: arg1,
    );
  }

  final Expression<dynamic> needle;
  final Expression<dynamic> haystack;

  @override
  int evaluate(EvaluationContext context) {
    return indexOfExpressionImpl(
      context,
      needle,
      haystack,
    );
  }

  @override
  List<Object?> get props => [
        needle,
        haystack,
      ];

  @override
  bool get stringify => true;
}

/// Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index. In a string, a UTF-16 surrogate pair counts as a single position.
class SliceExpression<T> extends Expression<T> {
  const SliceExpression({
    required this.input,
    required this.start,
    this.end,
    super.type,
  }) : super();

  /// Creates a new instance of [SliceExpression] by parsing the given [args] as a JSON list.
  factory SliceExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'slice', 'Invalid expression type: ${args[0]}, expected [slice]');

    var i = 1;

    // Parse arg0
    Expression<T> arg0;

    arg0 = Expression<T>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<int> arg1;

    arg1 = Expression<int>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<int>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<int>.fromJson(args[i]) : null;
      i++;
    }

    return SliceExpression(
      input: arg0,
      start: arg1,
      end: arg2,
    );
  }

  final Expression<T> input;
  final Expression<int> start;
  final Expression<int>? end;

  @override
  T evaluate(EvaluationContext context) {
    return sliceExpressionImpl(
      context,
      input,
      start,
      end,
    );
  }

  @override
  List<Object?> get props => [
        input,
        start,
        end,
      ];

  @override
  bool get stringify => true;
}

/// Retrieves a property value from the current feature's properties, or from another object if a second argument is provided. Returns null if the requested property is missing.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
///
///  - [Extrude polygons for 3D indoor mapping](https://maplibre.org/maplibre-gl-js/docs/examples/3d-extrusion-floorplan/)
class GetExpression<T> extends Expression<T> {
  const GetExpression({
    required this.key,
    this.object,
    super.type,
  }) : super();

  /// Creates a new instance of [GetExpression] by parsing the given [args] as a JSON list.
  factory GetExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'get', 'Invalid expression type: ${args[0]}, expected [get]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<Map<String, dynamic>>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<Map<String, dynamic>>.fromJson(args[i]) : null;
      i++;
    }

    return GetExpression(
      key: arg0,
      object: arg1,
    );
  }

  final Expression<String> key;
  final Expression<Map<String, dynamic>>? object;

  @override
  T evaluate(EvaluationContext context) {
    return getExpressionImpl(
      context,
      key,
      object,
    );
  }

  @override
  List<Object?> get props => [
        key,
        object,
      ];

  @override
  bool get stringify => true;
}

/// Tests for the presence of an property value in the current feature's properties, or from another object if a second argument is provided.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
class HasExpression extends Expression<bool> {
  const HasExpression({
    required this.key,
    this.object,
    super.type,
  }) : super();

  /// Creates a new instance of [HasExpression] by parsing the given [args] as a JSON list.
  factory HasExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'has', 'Invalid expression type: ${args[0]}, expected [has]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<Map<String, dynamic>>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<Map<String, dynamic>>.fromJson(args[i]) : null;
      i++;
    }

    return HasExpression(
      key: arg0,
      object: arg1,
    );
  }

  final Expression<String> key;
  final Expression<Map<String, dynamic>>? object;

  @override
  bool evaluate(EvaluationContext context) {
    return hasExpressionImpl(
      context,
      key,
      object,
    );
  }

  @override
  List<Object?> get props => [
        key,
        object,
      ];

  @override
  bool get stringify => true;
}

/// Gets the length of an array or string. In a string, a UTF-16 surrogate pair counts as a single position.
class LengthExpression extends Expression<int> {
  const LengthExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [LengthExpression] by parsing the given [args] as a JSON list.
  factory LengthExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'length', 'Invalid expression type: ${args[0]}, expected [length]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return LengthExpression(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  int evaluate(EvaluationContext context) {
    return lengthExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
class StepExpression<T> extends Expression<T> {
  const StepExpression({
    required this.input,
    required this.minOutput,
    required this.stops,
    super.type,
  }) : super();

  /// Creates a new instance of [StepExpression] by parsing the given [args] as a JSON list.
  factory StepExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'step', 'Invalid expression type: ${args[0]}, expected [step]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<T>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    return StepExpression(
      input: arg0,
      minOutput: arg1,
      stops: arg2,
    );
  }

  final Expression<num> input;
  final Expression<T> minOutput;
  final List<(num, Expression<T>)> stops;

  @override
  T evaluate(EvaluationContext context) {
    return stepExpressionImpl(
      context,
      input,
      minOutput,
      stops,
    );
  }

  @override
  List<Object?> get props => [
        input,
        minOutput,
        stops,
      ];

  @override
  bool get stringify => true;
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). The `input` may be any numeric expression (e.g., `["get", "population"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.
///
/// Interpolation types:
///
/// - `["linear"]`, or an expression returning one of those types: Interpolates linearly between the pair of stops just less than and just greater than the input.
///
/// - `["exponential", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.
///
/// - `["cubic-bezier", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.
///
///  - [Animate map camera around a point](https://maplibre.org/maplibre-gl-js/docs/examples/animate-camera-around-point/)
///
///  - [Change building color based on zoom level](https://maplibre.org/maplibre-gl-js/docs/examples/change-building-color-based-on-zoom-level/)
///
///  - [Create a heatmap layer](https://maplibre.org/maplibre-gl-js/docs/examples/heatmap-layer/)
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class InterpolateExpression<T> extends Expression<T> {
  const InterpolateExpression({
    required this.options,
    required this.input,
    required this.stops,
    super.type,
  }) : super();

  /// Creates a new instance of [InterpolateExpression] by parsing the given [args] as a JSON list.
  factory InterpolateExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'interpolate', 'Invalid expression type: ${args[0]}, expected [interpolate]');

    var i = 1;

    // Parse arg0
    InterpolationOptions arg0;

    arg0 = InterpolationOptions.fromJson(args[i] as dynamic);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<T>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    return InterpolateExpression(
      options: arg0,
      input: arg1,
      stops: arg2,
    );
  }

  final InterpolationOptions options;
  final Expression<num> input;
  final List<(num, Expression<T>)> stops;

  @override
  T evaluate(EvaluationContext context) {
    return interpolateExpressionImpl(
      context,
      options,
      input,
      stops,
    );
  }

  @override
  List<Object?> get props => [
        options,
        input,
        stops,
      ];

  @override
  bool get stringify => true;
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.
class InterpolateHclExpression extends Expression<Color> {
  const InterpolateHclExpression({
    required this.options,
    required this.input,
    required this.stops,
    super.type,
  }) : super();

  /// Creates a new instance of [InterpolateHclExpression] by parsing the given [args] as a JSON list.
  factory InterpolateHclExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'interpolate-hcl', 'Invalid expression type: ${args[0]}, expected [interpolate-hcl]');

    var i = 1;

    // Parse arg0
    InterpolationOptions arg0;

    arg0 = InterpolationOptions.fromJson(args[i] as dynamic);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<Color>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<Color>.fromJson(args[i + 1]),
      ));
    }

    return InterpolateHclExpression(
      options: arg0,
      input: arg1,
      stops: arg2,
    );
  }

  final InterpolationOptions options;
  final Expression<num> input;
  final List<(num, Expression<Color>)> stops;

  @override
  Color evaluate(EvaluationContext context) {
    return interpolateHclExpressionImpl(
      context,
      options,
      input,
      stops,
    );
  }

  @override
  List<Object?> get props => [
        options,
        input,
        stops,
      ];

  @override
  bool get stringify => true;
}

/// Produces continuous, smooth results by interpolating between pairs of input and output values ("stops"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.
class InterpolateLabExpression extends Expression<Color> {
  const InterpolateLabExpression({
    required this.options,
    required this.input,
    required this.stops,
    super.type,
  }) : super();

  /// Creates a new instance of [InterpolateLabExpression] by parsing the given [args] as a JSON list.
  factory InterpolateLabExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'interpolate-lab', 'Invalid expression type: ${args[0]}, expected [interpolate-lab]');

    var i = 1;

    // Parse arg0
    InterpolationOptions arg0;

    arg0 = InterpolationOptions.fromJson(args[i] as dynamic);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    List<(num, Expression<Color>)> arg2;

    arg2 = [];
    for (; i < args.length - 0; i += 2) {
      arg2.add((
        args[i + 0] as num,
        Expression<Color>.fromJson(args[i + 1]),
      ));
    }

    return InterpolateLabExpression(
      options: arg0,
      input: arg1,
      stops: arg2,
    );
  }

  final InterpolationOptions options;
  final Expression<num> input;
  final List<(num, Expression<Color>)> stops;

  @override
  Color evaluate(EvaluationContext context) {
    return interpolateLabExpressionImpl(
      context,
      options,
      input,
      stops,
    );
  }

  @override
  List<Object?> get props => [
        options,
        input,
        stops,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in MapLibre GL JS).
class IsSupportedScriptExpression extends Expression<bool> {
  const IsSupportedScriptExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [IsSupportedScriptExpression] by parsing the given [args] as a JSON list.
  factory IsSupportedScriptExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'is-supported-script', 'Invalid expression type: ${args[0]}, expected [is-supported-script]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return IsSupportedScriptExpression(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  bool evaluate(EvaluationContext context) {
    return isSupportedScriptExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
class UpcaseExpression extends Expression<String> {
  const UpcaseExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [UpcaseExpression] by parsing the given [args] as a JSON list.
  factory UpcaseExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'upcase', 'Invalid expression type: ${args[0]}, expected [upcase]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return UpcaseExpression(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  String evaluate(EvaluationContext context) {
    return upcaseExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
class DowncaseExpression extends Expression<String> {
  const DowncaseExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [DowncaseExpression] by parsing the given [args] as a JSON list.
  factory DowncaseExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'downcase', 'Invalid expression type: ${args[0]}, expected [downcase]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return DowncaseExpression(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  String evaluate(EvaluationContext context) {
    return downcaseExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.
///
///  - [Add a generated icon to the map](https://maplibre.org/maplibre-gl-js/docs/examples/add-image-missing-generated/)
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/fallback-image/)
///
///  - [Variable label placement](https://maplibre.org/maplibre-gl-js/docs/examples/variable-label-placement/)
class ConcatExpression extends Expression<String> {
  const ConcatExpression({
    required this.values,
    super.type,
  }) : super();

  /// Creates a new instance of [ConcatExpression] by parsing the given [args] as a JSON list.
  factory ConcatExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'concat', 'Invalid expression type: ${args[0]}, expected [concat]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ConcatExpression(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  String evaluate(EvaluationContext context) {
    return concatExpressionImpl(
      context,
      values,
    );
  }

  @override
  List<Object?> get props => [
        values,
      ];

  @override
  bool get stringify => true;
}

/// Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.
class ResolvedLocaleExpression extends Expression<String> {
  const ResolvedLocaleExpression({
    required this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [ResolvedLocaleExpression] by parsing the given [args] as a JSON list.
  factory ResolvedLocaleExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'resolved-locale', 'Invalid expression type: ${args[0]}, expected [resolved-locale]');

    var i = 1;

    // Parse arg0
    Expression<Collator> arg0;

    arg0 = Expression<Collator>.fromJson(args[i]);
    i++;

    return ResolvedLocaleExpression(
      collator: arg0,
    );
  }

  final Expression<Collator> collator;

  @override
  String evaluate(EvaluationContext context) {
    return resolvedLocaleExpressionImpl(
      context,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class CaseExpression<T> extends Expression<T> {
  const CaseExpression({
    required this.branches,
    required this.fallback,
    super.type,
  }) : super();

  /// Creates a new instance of [CaseExpression] by parsing the given [args] as a JSON list.
  factory CaseExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'case', 'Invalid expression type: ${args[0]}, expected [case]');

    var i = 1;

    // Parse arg0
    List<(Expression<bool>, Expression<T>)> arg0;

    arg0 = [];
    for (; i < args.length - 1; i += 2) {
      arg0.add((
        Expression<bool>.fromJson(args[i + 0]),
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    return CaseExpression(
      branches: arg0,
      fallback: arg1,
    );
  }

  final List<(Expression<bool>, Expression<T>)> branches;
  final Expression<T> fallback;

  @override
  T evaluate(EvaluationContext context) {
    return caseExpressionImpl(
      context,
      branches,
      fallback,
    );
  }

  @override
  List<Object?> get props => [
        branches,
        fallback,
      ];

  @override
  bool get stringify => true;
}

/// Selects the output whose label value matches the input value, or the fallback value if no match is found. The input can be any expression (e.g. `["get", "building_type"]`). Each label must be either:
///
///  - a single literal value; or
///
///  - an array of literal values, whose values must be all strings or all numbers (e.g. `[100, 101]` or `["c", "b"]`). The input matches if any of the values in the array matches, similar to the `"in"` operator.
///
/// Each label must be unique. If the input type does not match the type of the labels, the result will be the fallback value.
class MatchExpression<T> extends Expression<T> {
  const MatchExpression({
    required this.input,
    required this.branches,
    required this.fallback,
    super.type,
  }) : super();

  /// Creates a new instance of [MatchExpression] by parsing the given [args] as a JSON list.
  factory MatchExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'match', 'Invalid expression type: ${args[0]}, expected [match]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    List<(dynamic, Expression<T>)> arg1;

    arg1 = [];
    for (; i < args.length - 1; i += 2) {
      arg1.add((
        args[i + 0] as dynamic,
        Expression<T>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg2
    Expression<T> arg2;

    arg2 = Expression<T>.fromJson(args[i]);
    i++;

    return MatchExpression(
      input: arg0,
      branches: arg1,
      fallback: arg2,
    );
  }

  final Expression<dynamic> input;
  final List<(dynamic, Expression<T>)> branches;
  final Expression<T> fallback;

  @override
  T evaluate(EvaluationContext context) {
    return matchExpressionImpl(
      context,
      input,
      branches,
      fallback,
    );
  }

  @override
  List<Object?> get props => [
        input,
        branches,
        fallback,
      ];

  @override
  bool get stringify => true;
}

/// Evaluates each expression in turn until the first non-null value is obtained, and returns that value.
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/fallback-image/)
class CoalesceExpression<T> extends Expression<T> {
  const CoalesceExpression({
    required this.expressions,
    super.type,
  }) : super();

  /// Creates a new instance of [CoalesceExpression] by parsing the given [args] as a JSON list.
  factory CoalesceExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'coalesce', 'Invalid expression type: ${args[0]}, expected [coalesce]');

    var i = 1;

    // Parse arg0
    List<Expression<T>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<T>.fromJson(args[i]));
    }

    return CoalesceExpression(
      expressions: arg0,
    );
  }

  final List<Expression<T>> expressions;

  @override
  T evaluate(EvaluationContext context) {
    return coalesceExpressionImpl(
      context,
      expressions,
    );
  }

  @override
  List<Object?> get props => [
        expressions,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Add multiple geometries from one GeoJSON source](https://maplibre.org/maplibre-gl-js/docs/examples/multiple-geometries/)
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
///
///  - [Display buildings in 3D](https://maplibre.org/maplibre-gl-js/docs/examples/3d-buildings/)
///
///  - [Filter symbols by toggling a list](https://maplibre.org/maplibre-gl-js/docs/examples/filter-markers/)
class EqualsExpression extends Expression<bool> {
  const EqualsExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [EqualsExpression] by parsing the given [args] as a JSON list.
  factory EqualsExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '==', 'Invalid expression type: ${args[0]}, expected [==]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return EqualsExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return equalsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class NotEqualsExpression extends Expression<bool> {
  const NotEqualsExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [NotEqualsExpression] by parsing the given [args] as a JSON list.
  factory NotEqualsExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '!=', 'Invalid expression type: ${args[0]}, expected [!=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return NotEqualsExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return notEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
class GreaterThanExpression extends Expression<bool> {
  const GreaterThanExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [GreaterThanExpression] by parsing the given [args] as a JSON list.
  factory GreaterThanExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '>', 'Invalid expression type: ${args[0]}, expected [>]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return GreaterThanExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return greaterThanExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class LessThanExpression extends Expression<bool> {
  const LessThanExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [LessThanExpression] by parsing the given [args] as a JSON list.
  factory LessThanExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '<', 'Invalid expression type: ${args[0]}, expected [<]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return LessThanExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return lessThanExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class GreaterThanOrEqualsExpression extends Expression<bool> {
  const GreaterThanOrEqualsExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [GreaterThanOrEqualsExpression] by parsing the given [args] as a JSON list.
  factory GreaterThanOrEqualsExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '>=', 'Invalid expression type: ${args[0]}, expected [>=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return GreaterThanOrEqualsExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return greaterThanOrEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.
class LessThanOrEqualsExpression extends Expression<bool> {
  const LessThanOrEqualsExpression({
    required this.left,
    required this.right,
    this.collator,
    super.type,
  }) : super();

  /// Creates a new instance of [LessThanOrEqualsExpression] by parsing the given [args] as a JSON list.
  factory LessThanOrEqualsExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '<=', 'Invalid expression type: ${args[0]}, expected [<=]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<dynamic> arg1;

    arg1 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<Collator>? arg2;

    if (args.length > 3) {
      arg2 = args[i] != null ? Expression<Collator>.fromJson(args[i]) : null;
      i++;
    }

    return LessThanOrEqualsExpression(
      left: arg0,
      right: arg1,
      collator: arg2,
    );
  }

  final Expression<dynamic> left;
  final Expression<dynamic> right;
  final Expression<Collator>? collator;

  @override
  bool evaluate(EvaluationContext context) {
    return lessThanOrEqualsExpressionImpl(
      context,
      left,
      right,
      collator,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
        collator,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class AllExpression extends Expression<bool> {
  const AllExpression({
    required this.expressions,
    super.type,
  }) : super();

  /// Creates a new instance of [AllExpression] by parsing the given [args] as a JSON list.
  factory AllExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'all', 'Invalid expression type: ${args[0]}, expected [all]');

    var i = 1;

    // Parse arg0
    List<Expression<bool>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<bool>.fromJson(args[i]));
    }

    return AllExpression(
      expressions: arg0,
    );
  }

  final List<Expression<bool>> expressions;

  @override
  bool evaluate(EvaluationContext context) {
    return allExpressionImpl(
      context,
      expressions,
    );
  }

  @override
  List<Object?> get props => [
        expressions,
      ];

  @override
  bool get stringify => true;
}

/// Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.
class AnyExpression extends Expression<bool> {
  const AnyExpression({
    required this.expressions,
    super.type,
  }) : super();

  /// Creates a new instance of [AnyExpression] by parsing the given [args] as a JSON list.
  factory AnyExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'any', 'Invalid expression type: ${args[0]}, expected [any]');

    var i = 1;

    // Parse arg0
    List<Expression<bool>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<bool>.fromJson(args[i]));
    }

    return AnyExpression(
      expressions: arg0,
    );
  }

  final List<Expression<bool>> expressions;

  @override
  bool evaluate(EvaluationContext context) {
    return anyExpressionImpl(
      context,
      expressions,
    );
  }

  @override
  List<Object?> get props => [
        expressions,
      ];

  @override
  bool get stringify => true;
}

/// Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.
///
///  - [Create and style clusters](https://maplibre.org/maplibre-gl-js/docs/examples/cluster/)
class NotExpression extends Expression<bool> {
  const NotExpression({
    required this.expression,
    super.type,
  }) : super();

  /// Creates a new instance of [NotExpression] by parsing the given [args] as a JSON list.
  factory NotExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '!', 'Invalid expression type: ${args[0]}, expected [!]');

    var i = 1;

    // Parse arg0
    Expression<bool> arg0;

    arg0 = Expression<bool>.fromJson(args[i]);
    i++;

    return NotExpression(
      expression: arg0,
    );
  }

  final Expression<bool> expression;

  @override
  bool evaluate(EvaluationContext context) {
    return notExpressionImpl(
      context,
      expression,
    );
  }

  @override
  List<Object?> get props => [
        expression,
      ];

  @override
  bool get stringify => true;
}

/// Binds expressions to named variables, which can then be referenced in the result expression using `["var", "variable_name"]`.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class LetExpression<T> extends Expression<T> {
  const LetExpression({
    required this.bindings,
    required this.child,
    super.type,
  }) : super();

  /// Creates a new instance of [LetExpression] by parsing the given [args] as a JSON list.
  factory LetExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'let', 'Invalid expression type: ${args[0]}, expected [let]');

    var i = 1;

    // Parse arg0
    List<(String, Expression<Object?>)> arg0;

    arg0 = [];
    for (; i < args.length - 1; i += 2) {
      arg0.add((
        args[i + 0] as String,
        Expression<Object?>.fromJson(args[i + 1]),
      ));
    }

    // Parse arg1
    Expression<T> arg1;

    arg1 = Expression<T>.fromJson(args[i]);
    i++;

    return LetExpression(
      bindings: arg0,
      child: arg1,
    );
  }

  final List<(String, Expression<Object?>)> bindings;
  final Expression<T> child;

  @override
  T evaluate(EvaluationContext context) {
    return letExpressionImpl(
      context,
      bindings,
      child,
    );
  }

  @override
  List<Object?> get props => [
        bindings,
        child,
      ];

  @override
  bool get stringify => true;
}

/// References variable bound using `let`.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class VarExpression<T> extends Expression<T> {
  const VarExpression({
    required this.name,
    super.type,
  }) : super();

  /// Creates a new instance of [VarExpression] by parsing the given [args] as a JSON list.
  factory VarExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'var', 'Invalid expression type: ${args[0]}, expected [var]');

    var i = 1;

    // Parse arg0
    String arg0;

    arg0 = args[i] as String;
    i++;

    return VarExpression(
      name: arg0,
    );
  }

  final String name;

  @override
  T evaluate(EvaluationContext context) {
    return varExpressionImpl(
      context,
      name,
    );
  }

  @override
  List<Object?> get props => [
        name,
      ];

  @override
  bool get stringify => true;
}

/// Provides a literal array or object value.
///
///  - [Display and style rich text labels](https://maplibre.org/maplibre-gl-js/docs/examples/display-and-style-rich-text-labels/)
class LiteralExpression<T> extends Expression<T> {
  const LiteralExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [LiteralExpression] by parsing the given [args] as a JSON list.
  factory LiteralExpression.fromJson(List<dynamic> args) {
    return literalExpressionFromJsonImpl(args);
  }

  final T value;

  @override
  T evaluate(EvaluationContext context) {
    return literalExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.
class CollatorExpressionExpression extends Expression<Collator> {
  const CollatorExpressionExpression({
    required this.object,
    super.type,
  }) : super();

  /// Creates a new instance of [CollatorExpressionExpression] by parsing the given [args] as a JSON list.
  factory CollatorExpressionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'collator', 'Invalid expression type: ${args[0]}, expected [collator]');

    var i = 1;

    // Parse arg0
    ({Expression<bool>? caseSensitive, Expression<bool>? diacriticSensitive, Expression<String>? locale}) arg0;

    arg0 = (
      caseSensitive: args[i]['case-sensitive'] != null ? Expression<bool>.fromJson(args[i]['case-sensitive']) : null,
      diacriticSensitive:
          args[i]['diacritic-sensitive'] != null ? Expression<bool>.fromJson(args[i]['diacritic-sensitive']) : null,
      locale: args[i]['locale'] != null ? Expression<String>.fromJson(args[i]['locale']) : null,
    );
    i++;

    return CollatorExpressionExpression(
      object: arg0,
    );
  }

  final ({Expression<bool>? caseSensitive, Expression<bool>? diacriticSensitive, Expression<String>? locale}) object;

  @override
  Collator evaluate(EvaluationContext context) {
    return collatorExpressionImpl(
      context,
      object,
    );
  }

  @override
  List<Object?> get props => [
        object,
      ];

  @override
  bool get stringify => true;
}

/// Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`'image'`](#image) expression. Strings may be followed by a style override object that supports the following properties:
///
/// - `"text-font"`: Overrides the font stack specified by the root layout property.
///
/// - `"text-color"`: Overrides the color specified by the root paint property.
///
/// - `"font-scale"`: Applies a scaling factor on `text-size` as specified by the root layout property.
///
///  - [Change the case of labels](https://maplibre.org/maplibre-gl-js/docs/examples/change-case-of-labels/)
///
///  - [Display and style rich text labels](https://maplibre.org/maplibre-gl-js/docs/examples/display-and-style-rich-text-labels/)
class FormatExpression extends Expression<Formatted> {
  const FormatExpression() : super();

  /// Creates a new instance of [FormatExpression] by parsing the given [args] as a JSON list.
  factory FormatExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'format', 'Invalid expression type: ${args[0]}, expected [format]');

    return const FormatExpression();
  }

  @override
  Formatted evaluate(EvaluationContext context) {
    return formatExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.
///
///  - [Use a fallback image](https://maplibre.org/maplibre-gl-js/docs/examples/fallback-image/)
class ImageExpressionExpression extends Expression<ResolvedImage> {
  const ImageExpressionExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [ImageExpressionExpression] by parsing the given [args] as a JSON list.
  factory ImageExpressionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'image', 'Invalid expression type: ${args[0]}, expected [image]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return ImageExpressionExpression(
      value: arg0,
    );
  }

  final Expression<String> value;

  @override
  ResolvedImage evaluate(EvaluationContext context) {
    return imageExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.
///
///  - [Display HTML clusters with custom properties](https://maplibre.org/maplibre-gl-js/docs/examples/cluster-html/)
class NumberFormatExpression extends Expression<String> {
  const NumberFormatExpression({
    required this.number,
    required this.options,
    super.type,
  }) : super();

  /// Creates a new instance of [NumberFormatExpression] by parsing the given [args] as a JSON list.
  factory NumberFormatExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'number-format', 'Invalid expression type: ${args[0]}, expected [number-format]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    ({
      Expression<String>? currency,
      Expression<String>? locale,
      Expression<int>? maxFractionDigits,
      Expression<int>? minFractionDigits
    }) arg1;

    arg1 = (
      currency: args[i]['currency'] != null ? Expression<String>.fromJson(args[i]['currency']) : null,
      locale: args[i]['locale'] != null ? Expression<String>.fromJson(args[i]['locale']) : null,
      maxFractionDigits:
          args[i]['max-fraction-digits'] != null ? Expression<int>.fromJson(args[i]['max-fraction-digits']) : null,
      minFractionDigits:
          args[i]['min-fraction-digits'] != null ? Expression<int>.fromJson(args[i]['min-fraction-digits']) : null,
    );
    i++;

    return NumberFormatExpression(
      number: arg0,
      options: arg1,
    );
  }

  final Expression<num> number;
  final ({
    Expression<String>? currency,
    Expression<String>? locale,
    Expression<int>? maxFractionDigits,
    Expression<int>? minFractionDigits
  }) options;

  @override
  String evaluate(EvaluationContext context) {
    return numberFormatExpressionImpl(
      context,
      number,
      options,
    );
  }

  @override
  List<Object?> get props => [
        number,
        options,
      ];

  @override
  bool get stringify => true;
}

/// Asserts that the input is an array (optionally with a specific item type and length). If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.
class ArrayAssertionExpression extends Expression<List<dynamic>> {
  const ArrayAssertionExpression({
    required this.value,
    this.childType,
    this.childCount,
    super.type,
  }) : super();

  /// Creates a new instance of [ArrayAssertionExpression] by parsing the given [args] as a JSON list.
  factory ArrayAssertionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'array', 'Invalid expression type: ${args[0]}, expected [array]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    // Parse arg1
    Type? arg1;

    if (args.length > 2) {
      arg1 = args[i] as Type?;
      i++;
    }

    // Parse arg2
    int? arg2;

    if (args.length > 3) {
      arg2 = args[i] as int?;
      i++;
    }

    return ArrayAssertionExpression(
      value: arg0,
      childType: arg1,
      childCount: arg2,
    );
  }

  final Expression<dynamic> value;
  final Type? childType;
  final int? childCount;

  @override
  List<dynamic> evaluate(EvaluationContext context) {
    return arrayAssertionExpressionImpl(
      context,
      value,
      childType,
      childCount,
    );
  }

  @override
  List<Object?> get props => [
        value,
        childType,
        childCount,
      ];

  @override
  bool get stringify => true;
}

/// Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
class BooleanAssertionExpression extends Expression<bool> {
  const BooleanAssertionExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [BooleanAssertionExpression] by parsing the given [args] as a JSON list.
  factory BooleanAssertionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'boolean', 'Invalid expression type: ${args[0]}, expected [boolean]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return BooleanAssertionExpression(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  bool evaluate(EvaluationContext context) {
    return booleanAssertionExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.
class NumberAssertionExpression extends Expression<num> {
  const NumberAssertionExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [NumberAssertionExpression] by parsing the given [args] as a JSON list.
  factory NumberAssertionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'number', 'Invalid expression type: ${args[0]}, expected [number]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return NumberAssertionExpression(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  num evaluate(EvaluationContext context) {
    return numberAssertionExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.
class StringAssertionExpression extends Expression<String> {
  const StringAssertionExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [StringAssertionExpression] by parsing the given [args] as a JSON list.
  factory StringAssertionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'string', 'Invalid expression type: ${args[0]}, expected [string]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return StringAssertionExpression(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  String evaluate(EvaluationContext context) {
    return stringAssertionExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.
class ObjectAssertionExpression extends Expression<Map<String, dynamic>> {
  const ObjectAssertionExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [ObjectAssertionExpression] by parsing the given [args] as a JSON list.
  factory ObjectAssertionExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'object', 'Invalid expression type: ${args[0]}, expected [object]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ObjectAssertionExpression(
      args: arg0,
    );
  }

  final List<Expression<dynamic>> args;

  @override
  Map<String, dynamic> evaluate(EvaluationContext context) {
    return objectAssertionExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Returns a string describing the type of the given value.
class TypeOfExpression extends Expression<String> {
  const TypeOfExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [TypeOfExpression] by parsing the given [args] as a JSON list.
  factory TypeOfExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'typeof', 'Invalid expression type: ${args[0]}, expected [typeof]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return TypeOfExpression(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  String evaluate(EvaluationContext context) {
    return typeOfExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Converts the input value to a string. If the input is `null`, the result is `""`. If the input is a boolean, the result is `"true"` or `"false"`. If the input is a number, it is converted to a string as specified by the ["NumberToString" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `"rgba(r,g,b,a)"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.
///
///  - [Create a time slider](https://maplibre.org/maplibre-gl-js/docs/examples/timeline-animation/)
class ToStringExpression extends Expression<String> {
  const ToStringExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [ToStringExpression] by parsing the given [args] as a JSON list.
  factory ToStringExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-string', 'Invalid expression type: ${args[0]}, expected [to-string]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return ToStringExpression(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  String evaluate(EvaluationContext context) {
    return toStringExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the ["ToNumber Applied to the String Type" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.
class ToNumberExpression extends Expression<num> {
  const ToNumberExpression({
    required this.values,
    super.type,
  }) : super();

  /// Creates a new instance of [ToNumberExpression] by parsing the given [args] as a JSON list.
  factory ToNumberExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-number', 'Invalid expression type: ${args[0]}, expected [to-number]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ToNumberExpression(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  num evaluate(EvaluationContext context) {
    return toNumberExpressionImpl(
      context,
      values,
    );
  }

  @override
  List<Object?> get props => [
        values,
      ];

  @override
  bool get stringify => true;
}

/// Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.
class ToBooleanExpression extends Expression<bool> {
  const ToBooleanExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [ToBooleanExpression] by parsing the given [args] as a JSON list.
  factory ToBooleanExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-boolean', 'Invalid expression type: ${args[0]}, expected [to-boolean]');

    var i = 1;

    // Parse arg0
    Expression<dynamic> arg0;

    arg0 = Expression<dynamic>.fromJson(args[i]);
    i++;

    return ToBooleanExpression(
      value: arg0,
    );
  }

  final Expression<dynamic> value;

  @override
  bool evaluate(EvaluationContext context) {
    return toBooleanExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class ToColorExpression extends Expression<Color> {
  const ToColorExpression({
    required this.values,
    super.type,
  }) : super();

  /// Creates a new instance of [ToColorExpression] by parsing the given [args] as a JSON list.
  factory ToColorExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-color', 'Invalid expression type: ${args[0]}, expected [to-color]');

    var i = 1;

    // Parse arg0
    List<Expression<dynamic>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<dynamic>.fromJson(args[i]));
    }

    return ToColorExpression(
      values: arg0,
    );
  }

  final List<Expression<dynamic>> values;

  @override
  Color evaluate(EvaluationContext context) {
    return toColorExpressionImpl(
      context,
      values,
    );
  }

  @override
  List<Object?> get props => [
        values,
      ];

  @override
  bool get stringify => true;
}

/// Returns a four-element array containing the input color's red, green, blue, and alpha components, in that order.
class ToRgbaExpression extends Expression<List<num>> {
  const ToRgbaExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [ToRgbaExpression] by parsing the given [args] as a JSON list.
  factory ToRgbaExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'to-rgba', 'Invalid expression type: ${args[0]}, expected [to-rgba]');

    var i = 1;

    // Parse arg0
    Expression<Color> arg0;

    arg0 = Expression<Color>.fromJson(args[i]);
    i++;

    return ToRgbaExpression(
      value: arg0,
    );
  }

  final Expression<Color> value;

  @override
  List<num> evaluate(EvaluationContext context) {
    return toRgbaExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.
class RgbExpression extends Expression<Color> {
  const RgbExpression({
    required this.r,
    required this.g,
    required this.b,
    super.type,
  }) : super();

  /// Creates a new instance of [RgbExpression] by parsing the given [args] as a JSON list.
  factory RgbExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'rgb', 'Invalid expression type: ${args[0]}, expected [rgb]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<num> arg2;

    arg2 = Expression<num>.fromJson(args[i]);
    i++;

    return RgbExpression(
      r: arg0,
      g: arg1,
      b: arg2,
    );
  }

  final Expression<num> r;
  final Expression<num> g;
  final Expression<num> b;

  @override
  Color evaluate(EvaluationContext context) {
    return rgbExpressionImpl(
      context,
      r,
      g,
      b,
    );
  }

  @override
  List<Object?> get props => [
        r,
        g,
        b,
      ];

  @override
  bool get stringify => true;
}

/// Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.
class RgbaExpression extends Expression<Color> {
  const RgbaExpression({
    required this.r,
    required this.g,
    required this.b,
    required this.a,
    super.type,
  }) : super();

  /// Creates a new instance of [RgbaExpression] by parsing the given [args] as a JSON list.
  factory RgbaExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'rgba', 'Invalid expression type: ${args[0]}, expected [rgba]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg2
    Expression<num> arg2;

    arg2 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg3
    Expression<num> arg3;

    arg3 = Expression<num>.fromJson(args[i]);
    i++;

    return RgbaExpression(
      r: arg0,
      g: arg1,
      b: arg2,
      a: arg3,
    );
  }

  final Expression<num> r;
  final Expression<num> g;
  final Expression<num> b;
  final Expression<num> a;

  @override
  Color evaluate(EvaluationContext context) {
    return rgbaExpressionImpl(
      context,
      r,
      g,
      b,
      a,
    );
  }

  @override
  List<Object?> get props => [
        r,
        g,
        b,
        a,
      ];

  @override
  bool get stringify => true;
}

/// Gets the feature properties object.  Note that in some cases, it may be more efficient to use ["get", "property_name"] directly.
class PropertiesExpression extends Expression<Map<String, dynamic>> {
  const PropertiesExpression() : super();

  /// Creates a new instance of [PropertiesExpression] by parsing the given [args] as a JSON list.
  factory PropertiesExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'properties', 'Invalid expression type: ${args[0]}, expected [properties]');

    return const PropertiesExpression();
  }

  @override
  Map<String, dynamic> evaluate(EvaluationContext context) {
    return propertiesExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Retrieves a property value from the current feature's state. Returns null if the requested property is not present on the feature's state. A feature's state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. When `source.promoteId` is not provided, features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. When `source.promoteId` is provided, features are identified by their `promoteId` property, which may be a number, string, or any primitive data type. Note that ["feature-state"] can only be used with paint properties that support data-driven styling.
///
///  - [Create a hover effect](https://maplibre.org/maplibre-gl-js/docs/examples/hover-styles/)
class FeatureStateExpression extends Expression<dynamic> {
  const FeatureStateExpression({
    required this.key,
    super.type,
  }) : super();

  /// Creates a new instance of [FeatureStateExpression] by parsing the given [args] as a JSON list.
  factory FeatureStateExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'feature-state', 'Invalid expression type: ${args[0]}, expected [feature-state]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return FeatureStateExpression(
      key: arg0,
    );
  }

  final Expression<String> key;

  @override
  dynamic evaluate(EvaluationContext context) {
    return featureStateExpressionImpl(
      context,
      key,
    );
  }

  @override
  List<Object?> get props => [
        key,
      ];

  @override
  bool get stringify => true;
}

/// Gets the feature's geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.
class GeometryTypeExpression extends Expression<String> {
  const GeometryTypeExpression() : super();

  /// Creates a new instance of [GeometryTypeExpression] by parsing the given [args] as a JSON list.
  factory GeometryTypeExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'geometry-type', 'Invalid expression type: ${args[0]}, expected [geometry-type]');

    return const GeometryTypeExpression();
  }

  @override
  String evaluate(EvaluationContext context) {
    return geometryTypeExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Gets the feature's id, if it has one.
class IdExpression extends Expression<String?> {
  const IdExpression() : super();

  /// Creates a new instance of [IdExpression] by parsing the given [args] as a JSON list.
  factory IdExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'id', 'Invalid expression type: ${args[0]}, expected [id]');

    return const IdExpression();
  }

  @override
  String? evaluate(EvaluationContext context) {
    return idExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Gets the progress along a gradient line. Can only be used in the `line-gradient` property.
class LineProgressExpression extends Expression<double> {
  const LineProgressExpression() : super();

  /// Creates a new instance of [LineProgressExpression] by parsing the given [args] as a JSON list.
  factory LineProgressExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'line-progress', 'Invalid expression type: ${args[0]}, expected [line-progress]');

    return const LineProgressExpression();
  }

  @override
  double evaluate(EvaluationContext context) {
    return lineProgressExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.
class AccumulatedExpression extends Expression<double> {
  const AccumulatedExpression({
    required this.key,
    super.type,
  }) : super();

  /// Creates a new instance of [AccumulatedExpression] by parsing the given [args] as a JSON list.
  factory AccumulatedExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'accumulated', 'Invalid expression type: ${args[0]}, expected [accumulated]');

    var i = 1;

    // Parse arg0
    Expression<String> arg0;

    arg0 = Expression<String>.fromJson(args[i]);
    i++;

    return AccumulatedExpression(
      key: arg0,
    );
  }

  final Expression<String> key;

  @override
  double evaluate(EvaluationContext context) {
    return accumulatedExpressionImpl(
      context,
      key,
    );
  }

  @override
  List<Object?> get props => [
        key,
      ];

  @override
  bool get stringify => true;
}

/// Returns mathematical constant ln(2).
class Ln2Expression extends Expression<num> {
  const Ln2Expression() : super();

  /// Creates a new instance of [Ln2Expression] by parsing the given [args] as a JSON list.
  factory Ln2Expression.fromJson(List<dynamic> args) {
    assert(args[0] == 'ln2', 'Invalid expression type: ${args[0]}, expected [ln2]');

    return const Ln2Expression();
  }

  @override
  num evaluate(EvaluationContext context) {
    return ln2ExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Returns the mathematical constant pi.
class PiExpression extends Expression<num> {
  const PiExpression() : super();

  /// Creates a new instance of [PiExpression] by parsing the given [args] as a JSON list.
  factory PiExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'pi', 'Invalid expression type: ${args[0]}, expected [pi]');

    return const PiExpression();
  }

  @override
  num evaluate(EvaluationContext context) {
    return piExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Returns the mathematical constant e.
class EExpression extends Expression<num> {
  const EExpression() : super();

  /// Creates a new instance of [EExpression] by parsing the given [args] as a JSON list.
  factory EExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'e', 'Invalid expression type: ${args[0]}, expected [e]');

    return const EExpression();
  }

  @override
  num evaluate(EvaluationContext context) {
    return eExpressionImpl(
      context,
    );
  }

  @override
  List<Object?> get props => [];

  @override
  bool get stringify => true;
}

/// Returns the sum of the inputs.
class AddExpression extends Expression<num> {
  const AddExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [AddExpression] by parsing the given [args] as a JSON list.
  factory AddExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '+', 'Invalid expression type: ${args[0]}, expected [+]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return AddExpression(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return addExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Returns the product of the inputs.
class MultiplyExpression extends Expression<num> {
  const MultiplyExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [MultiplyExpression] by parsing the given [args] as a JSON list.
  factory MultiplyExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '*', 'Invalid expression type: ${args[0]}, expected [*]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return MultiplyExpression(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return multiplyExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.
class MinusExpression extends Expression<num> {
  const MinusExpression({
    required this.left,
    this.right,
    super.type,
  }) : super();

  /// Creates a new instance of [MinusExpression] by parsing the given [args] as a JSON list.
  factory MinusExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '-', 'Invalid expression type: ${args[0]}, expected [-]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num>? arg1;

    if (args.length > 2) {
      arg1 = args[i] != null ? Expression<num>.fromJson(args[i]) : null;
      i++;
    }

    return MinusExpression(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num>? right;

  @override
  num evaluate(EvaluationContext context) {
    return minusExpressionImpl(
      context,
      left,
      right,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
      ];

  @override
  bool get stringify => true;
}

/// Returns the result of floating point division of the first input by the second.
///
///  - [Visualize population density](https://maplibre.org/maplibre-gl-js/docs/examples/visualize-population-density/)
class DivideExpression extends Expression<num> {
  const DivideExpression({
    required this.left,
    required this.right,
    super.type,
  }) : super();

  /// Creates a new instance of [DivideExpression] by parsing the given [args] as a JSON list.
  factory DivideExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '/', 'Invalid expression type: ${args[0]}, expected [/]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return DivideExpression(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num> right;

  @override
  num evaluate(EvaluationContext context) {
    return divideExpressionImpl(
      context,
      left,
      right,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
      ];

  @override
  bool get stringify => true;
}

/// Returns the remainder after integer division of the first input by the second.
class ModExpression extends Expression<num> {
  const ModExpression({
    required this.left,
    required this.right,
    super.type,
  }) : super();

  /// Creates a new instance of [ModExpression] by parsing the given [args] as a JSON list.
  factory ModExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '%', 'Invalid expression type: ${args[0]}, expected [%]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return ModExpression(
      left: arg0,
      right: arg1,
    );
  }

  final Expression<num> left;
  final Expression<num> right;

  @override
  num evaluate(EvaluationContext context) {
    return modExpressionImpl(
      context,
      left,
      right,
    );
  }

  @override
  List<Object?> get props => [
        left,
        right,
      ];

  @override
  bool get stringify => true;
}

/// Returns the result of raising the first input to the power specified by the second.
class PowExpression extends Expression<num> {
  const PowExpression({
    required this.base,
    required this.exponent,
    super.type,
  }) : super();

  /// Creates a new instance of [PowExpression] by parsing the given [args] as a JSON list.
  factory PowExpression.fromJson(List<dynamic> args) {
    assert(args[0] == '^', 'Invalid expression type: ${args[0]}, expected [^]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    // Parse arg1
    Expression<num> arg1;

    arg1 = Expression<num>.fromJson(args[i]);
    i++;

    return PowExpression(
      base: arg0,
      exponent: arg1,
    );
  }

  final Expression<num> base;
  final Expression<num> exponent;

  @override
  num evaluate(EvaluationContext context) {
    return powExpressionImpl(
      context,
      base,
      exponent,
    );
  }

  @override
  List<Object?> get props => [
        base,
        exponent,
      ];

  @override
  bool get stringify => true;
}

/// Returns the square root of the input.
class SqrtExpression extends Expression<num> {
  const SqrtExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [SqrtExpression] by parsing the given [args] as a JSON list.
  factory SqrtExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'sqrt', 'Invalid expression type: ${args[0]}, expected [sqrt]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return SqrtExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return sqrtExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the base-ten logarithm of the input.
class Log10Expression extends Expression<num> {
  const Log10Expression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [Log10Expression] by parsing the given [args] as a JSON list.
  factory Log10Expression.fromJson(List<dynamic> args) {
    assert(args[0] == 'log10', 'Invalid expression type: ${args[0]}, expected [log10]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Log10Expression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return log10ExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the natural logarithm of the input.
class LnExpression extends Expression<num> {
  const LnExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [LnExpression] by parsing the given [args] as a JSON list.
  factory LnExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'ln', 'Invalid expression type: ${args[0]}, expected [ln]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return LnExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return lnExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the base-two logarithm of the input.
class Log2Expression extends Expression<num> {
  const Log2Expression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [Log2Expression] by parsing the given [args] as a JSON list.
  factory Log2Expression.fromJson(List<dynamic> args) {
    assert(args[0] == 'log2', 'Invalid expression type: ${args[0]}, expected [log2]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return Log2Expression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return log2ExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the sine of the input.
class SinExpression extends Expression<num> {
  const SinExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [SinExpression] by parsing the given [args] as a JSON list.
  factory SinExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'sin', 'Invalid expression type: ${args[0]}, expected [sin]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return SinExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return sinExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the cosine of the input.
class CosExpression extends Expression<num> {
  const CosExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [CosExpression] by parsing the given [args] as a JSON list.
  factory CosExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'cos', 'Invalid expression type: ${args[0]}, expected [cos]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return CosExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return cosExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the tangent of the input.
class TanExpression extends Expression<num> {
  const TanExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [TanExpression] by parsing the given [args] as a JSON list.
  factory TanExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'tan', 'Invalid expression type: ${args[0]}, expected [tan]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return TanExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return tanExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the arcsine of the input.
class AsinExpression extends Expression<num> {
  const AsinExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [AsinExpression] by parsing the given [args] as a JSON list.
  factory AsinExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'asin', 'Invalid expression type: ${args[0]}, expected [asin]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return AsinExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return asinExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the arccosine of the input.
class AcosExpression extends Expression<num> {
  const AcosExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [AcosExpression] by parsing the given [args] as a JSON list.
  factory AcosExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'acos', 'Invalid expression type: ${args[0]}, expected [acos]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return AcosExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return acosExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the arctangent of the input.
class AtanExpression extends Expression<num> {
  const AtanExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [AtanExpression] by parsing the given [args] as a JSON list.
  factory AtanExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'atan', 'Invalid expression type: ${args[0]}, expected [atan]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return AtanExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return atanExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the minimum value of the inputs.
class MinExpression extends Expression<num> {
  const MinExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [MinExpression] by parsing the given [args] as a JSON list.
  factory MinExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'min', 'Invalid expression type: ${args[0]}, expected [min]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return MinExpression(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return minExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Returns the maximum value of the inputs.
class MaxExpression extends Expression<num> {
  const MaxExpression({
    required this.args,
    super.type,
  }) : super();

  /// Creates a new instance of [MaxExpression] by parsing the given [args] as a JSON list.
  factory MaxExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'max', 'Invalid expression type: ${args[0]}, expected [max]');

    var i = 1;

    // Parse arg0
    List<Expression<num>> arg0;

    arg0 = [];
    for (; i < args.length - 0; i += 1) {
      arg0.add(Expression<num>.fromJson(args[i]));
    }

    return MaxExpression(
      args: arg0,
    );
  }

  final List<Expression<num>> args;

  @override
  num evaluate(EvaluationContext context) {
    return maxExpressionImpl(
      context,
      args,
    );
  }

  @override
  List<Object?> get props => [
        args,
      ];

  @override
  bool get stringify => true;
}

/// Returns the absolute value of the input.
class AbsExpression extends Expression<num> {
  const AbsExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [AbsExpression] by parsing the given [args] as a JSON list.
  factory AbsExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'abs', 'Invalid expression type: ${args[0]}, expected [abs]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return AbsExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return absExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `["round", -1.5]` evaluates to -2.
class RoundExpression extends Expression<num> {
  const RoundExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [RoundExpression] by parsing the given [args] as a JSON list.
  factory RoundExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'round', 'Invalid expression type: ${args[0]}, expected [round]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return RoundExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return roundExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the smallest integer that is greater than or equal to the input.
class CeilExpression extends Expression<num> {
  const CeilExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [CeilExpression] by parsing the given [args] as a JSON list.
  factory CeilExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'ceil', 'Invalid expression type: ${args[0]}, expected [ceil]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return CeilExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return ceilExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

/// Returns the largest integer that is less than or equal to the input.
class FloorExpression extends Expression<num> {
  const FloorExpression({
    required this.value,
    super.type,
  }) : super();

  /// Creates a new instance of [FloorExpression] by parsing the given [args] as a JSON list.
  factory FloorExpression.fromJson(List<dynamic> args) {
    assert(args[0] == 'floor', 'Invalid expression type: ${args[0]}, expected [floor]');

    var i = 1;

    // Parse arg0
    Expression<num> arg0;

    arg0 = Expression<num>.fromJson(args[i]);
    i++;

    return FloorExpression(
      value: arg0,
    );
  }

  final Expression<num> value;

  @override
  num evaluate(EvaluationContext context) {
    return floorExpressionImpl(
      context,
      value,
    );
  }

  @override
  List<Object?> get props => [
        value,
      ];

  @override
  bool get stringify => true;
}

Expression<T> expressionFromJson<T>(List<dynamic> args) {
  return switch (args[0] as String) {
    'zoom' => ZoomExpression.fromJson(args),
    'at' => AtExpression.fromJson(args),
    'in' => InExpression.fromJson(args),
    'index-of' => IndexOfExpression.fromJson(args),
    'slice' => SliceExpression<T>.fromJson(args),
    'get' => GetExpression<T>.fromJson(args),
    'has' => HasExpression.fromJson(args),
    'length' => LengthExpression.fromJson(args),
    'step' => StepExpression<T>.fromJson(args),
    'interpolate' => InterpolateExpression<T>.fromJson(args),
    'interpolate-hcl' => InterpolateHclExpression.fromJson(args),
    'interpolate-lab' => InterpolateLabExpression.fromJson(args),
    'is-supported-script' => IsSupportedScriptExpression.fromJson(args),
    'upcase' => UpcaseExpression.fromJson(args),
    'downcase' => DowncaseExpression.fromJson(args),
    'concat' => ConcatExpression.fromJson(args),
    'resolved-locale' => ResolvedLocaleExpression.fromJson(args),
    'case' => CaseExpression<T>.fromJson(args),
    'match' => MatchExpression<T>.fromJson(args),
    'coalesce' => CoalesceExpression<T>.fromJson(args),
    '==' => EqualsExpression.fromJson(args),
    '!=' => NotEqualsExpression.fromJson(args),
    '>' => GreaterThanExpression.fromJson(args),
    '<' => LessThanExpression.fromJson(args),
    '>=' => GreaterThanOrEqualsExpression.fromJson(args),
    '<=' => LessThanOrEqualsExpression.fromJson(args),
    'all' => AllExpression.fromJson(args),
    'any' => AnyExpression.fromJson(args),
    '!' => NotExpression.fromJson(args),
    'let' => LetExpression<T>.fromJson(args),
    'var' => VarExpression<T>.fromJson(args),
    'literal' => LiteralExpression<T>.fromJson(args),
    'collator' => CollatorExpressionExpression.fromJson(args),
    'format' => FormatExpression.fromJson(args),
    'image' => ImageExpressionExpression.fromJson(args),
    'number-format' => NumberFormatExpression.fromJson(args),
    'array' => ArrayAssertionExpression.fromJson(args),
    'boolean' => BooleanAssertionExpression.fromJson(args),
    'number' => NumberAssertionExpression.fromJson(args),
    'string' => StringAssertionExpression.fromJson(args),
    'object' => ObjectAssertionExpression.fromJson(args),
    'typeof' => TypeOfExpression.fromJson(args),
    'to-string' => ToStringExpression.fromJson(args),
    'to-number' => ToNumberExpression.fromJson(args),
    'to-boolean' => ToBooleanExpression.fromJson(args),
    'to-color' => ToColorExpression.fromJson(args),
    'to-rgba' => ToRgbaExpression.fromJson(args),
    'rgb' => RgbExpression.fromJson(args),
    'rgba' => RgbaExpression.fromJson(args),
    'properties' => PropertiesExpression.fromJson(args),
    'feature-state' => FeatureStateExpression.fromJson(args),
    'geometry-type' => GeometryTypeExpression.fromJson(args),
    'id' => IdExpression.fromJson(args),
    'line-progress' => LineProgressExpression.fromJson(args),
    'accumulated' => AccumulatedExpression.fromJson(args),
    'ln2' => Ln2Expression.fromJson(args),
    'pi' => PiExpression.fromJson(args),
    'e' => EExpression.fromJson(args),
    '+' => AddExpression.fromJson(args),
    '*' => MultiplyExpression.fromJson(args),
    '-' => MinusExpression.fromJson(args),
    '/' => DivideExpression.fromJson(args),
    '%' => ModExpression.fromJson(args),
    '^' => PowExpression.fromJson(args),
    'sqrt' => SqrtExpression.fromJson(args),
    'log10' => Log10Expression.fromJson(args),
    'ln' => LnExpression.fromJson(args),
    'log2' => Log2Expression.fromJson(args),
    'sin' => SinExpression.fromJson(args),
    'cos' => CosExpression.fromJson(args),
    'tan' => TanExpression.fromJson(args),
    'asin' => AsinExpression.fromJson(args),
    'acos' => AcosExpression.fromJson(args),
    'atan' => AtanExpression.fromJson(args),
    'min' => MinExpression.fromJson(args),
    'max' => MaxExpression.fromJson(args),
    'abs' => AbsExpression.fromJson(args),
    'round' => RoundExpression.fromJson(args),
    'ceil' => CeilExpression.fromJson(args),
    'floor' => FloorExpression.fromJson(args),
    _ => throw Exception('Unknown expression type: ${args[0]}'),
  } as Expression<T>;
}
